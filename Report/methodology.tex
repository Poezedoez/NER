\section{Methodology}
\label{sec:meth}


\subsection{Description of the data}
The dataset is a set of lobby documents that has been scraped from the web. Lobbying can be defined as the act of attempting to influence decisions made by officials in a government, most often legislators or members of regulatory agencies. Lobby documents are for example: resolutions, chamber inquiries, letters to the government and more. A distribution of different types can be seen in figure \ref{fig:data_dis}. The result of scraping these documents is that certain figures or itemization structures are textualized into words concatenated with itemization numbers, table entry titles or something similar. However, Frog's tokenization module will most of the time find the correct tokens.  These documents are exported as consistent JSON dicts, with for each doc corresponding meta information about the document such as the document ID, source, and type. The format can easily be read with Python. For domain reduction purposes, only parliamentary items are included in the data set. These items form the majority of the items and are in itself a mix of all types, except for the news items, in which the named entities vary greatly in domain compared to the parliamentary items.

\begin{figure} \label{fig:data_dis}
\centering
\begin{tabular}{l*{6}{c}r}
Type              & Count \\
\hline
Parliamentary item & 131906  \\
News item & 95261 \\
Chamber inquiry & 38804  \\
Voting & 20930 \\
Chamber letter & 19828 \\
Agenda item & 18950  \\
Resolutions & 4792 \\
\end{tabular}
\caption{The distribution of the initial data}
\end{figure}

\subsection{Methods}
The following sections will describe the stages required to examine the suitability of Frog for doing NER on parliamentary items. I will first describe how Frog has been used. Then I will go over the preparation needed to evaluate Frog on the CoNLL-2002 data set and the set of Parliamentary Items. Lastly I will explain how the reclassification of entity types was performed. 

\subsubsection{Employment of Frog}
Frog is open-source software that can be modified or redistributed under the GNU General Public License\footnote{\url{http://www.gnu.org/copyleft/gpl.html}}. The results in this paper are acquired by running Frog through a virtual machine on Windows. All necessary dependencies of Frog, including Frog itself, are provided by the LaMachine software distribution\footnote{\url{https://proycon.github.io/LaMachine/}}. Frog can be run through Python using the python-frog binding which is also inlcuded in the virtual machine.

\subsubsection{Evaluation method}
The CoNLL-2002 data set uses the following format. $$TOKEN -whiteline- POS -whiteline- IOB$$ Every line contains three things, each seperated by space: the token, which is an unprocessed word from a sentence, the token its corresponding part-of-speech, and the token its IOB-tag. Frog its Folia output looks similar with tab-delimited column format , but with additional information per token. To release Frog on CoNLL, the test set first has to be reformatted to its original text. This is done by removing the PoS and IOB-tags, concatenating the remaining words into their original sentences thereafter.  Frog chunks together multi-word entities and other words that are closely related on one line in the output. This will make it differ from the CoNLL output, as such the output is splitted with python using regular expressions. Now the processed text has the same line mapping per token as CoNLL.

It needs to be taken into account that the annotation guidelines for the SoNar corpus, on which Frog is trained, differ from CoNLL. SoNar has a wider range of entity types, with addition of EVE for event and PRO for product. These types are annotated in CoNLL as MISC. Therefore the additional types that Frog outputs are mapped to MISC. There is also a guideline difference regarding locational adjectives, such as 'Dutch' or 'European'. CoNLL guidelines\footnote{\url{http://www.cnts.ua.ac.be/conll2003/ner/annotation.txt}} annotate such an adjective as MISC, while Frog is trained to assign LOC as type. These LOC outputs of Frog have to be reassigned to MISC as well.

\subsubsection{Reclassification of entity types}
Firstly, all found entities are re-evaluated by \textbf{search in a gazetteer} in the domain of parliamentary items. This gazetteer is constructed with a combination of automatic extraction of entities with Frog and manual annotation of the correct type. The automatic extraction is performed on the training set of thousand parliamentary items. The extracted entities are sorted on popularity, giving annotation priority to the most common entities. The effectiveness of this step is dependent on the 1) size of the gazetteer 2) relevance of the training set 3) recall performance of Frog. Entities that do not appear in the gazetteer cannot be reclassified.

In the case of unknown words the contextual word relations may indicate a type correctly, however, with multiple occurrences of the same entity throughout a text, context differs from time to time. As a result an unambiguous entity can be tagged correctly as a PER 90\% of the time, but have an incorrect type assigned for the remaining 10\%. This is expected to be resolved using \textbf{majority voting}. In the case when a certain type is dominant over a minority, this minority is reclassified as the dominant type. To retrieve information regarding the dominant types per entity, a train set of thousand parliamentary items has been processed by Frog. The total occurrences of the entity types have been counted over all documents. For each token in the test set that has been assigned to be an entity, we perform majority voting. Whether an entity type is dominant for that entity is decided based on a threshold value. When the fraction of an entity type over the total amount of entity type counts is larger than the threshold value, the type is considered dominant.

A combination of these reclassification steps can be seen in algorithm \ref{alg:pseudo}, which shows the procedure in pseudocode.

\begin{algorithm} \label{alg:pseudo}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}

    \underline{reclassify} $(frogged\_file, vote\_file, gazetteer\_file)$\;
    \Input{Three files (path) each containing: the output of the Frogged text in folia-XML format, a dict of the counts for each type per entity, a dict of entities and their correct type}
    \Output{CoNLL format with reclassified types}
    treshold $\leftarrow$ 0.7\\
    type\_counts $\leftarrow$ load(vote\_file)\\
    gazetteer $\leftarrow$ load(gazetteer\_file)\\
    \ForEach{line in frogged\_file}{
        token, lemma, pos, chunk, iob+type etc. $\leftarrow$ split(line)\\
        iob $\leftarrow$ split(iob+type-tag)\\
        \If{is\_entity(token)}{
            new\_type $\leftarrow$ lookup(token, gazetteer)\\
            \tcp{if token is in gazetteer, no majority vote needed}
            \eIf{new\_type}{
                line $\leftarrow$ token, pos, iob+new\_type\\
            }{
                new\_type $\leftarrow$ vote\_type(token, type\_counts, treshold)\\
                \If{new\_type}{
                    line $\leftarrow$ token, pos, iob+new\_type\\
                }
            }
            
        }
    }
    
    \underline{vote\_type} $(token, type\_counts, treshold)$\;
    \Input{token of which to decide the type, the type\_counts dictionary, and the treshold to enact on revoting}
    \Output{new type for the token, none returned otherwise}
    new\_type $\leftarrow$ max(type\_counts[token])\\
    confidence\_score $\leftarrow$ max(type\_counts[token]) / total(type\_counts[token])\\
    \If{confidence\_score $\textgreater$ treshold}{
        \Return{new\_type}
    }
        
    \caption{Reclassification of entity types in Frog output using majority voting and a type gazetteer}
\end{algorithm}





